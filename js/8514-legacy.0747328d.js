"use strict";(self["webpackChunkaugest"]=self["webpackChunkaugest"]||[]).push([[8514],{98514:function(n,e,t){t.r(e),t.d(e,{default:function(){return d}});var s=t(19812),l=(0,s._)("html",null,[(0,s._)("head"),(0,s._)("body",null,[(0,s._)("h3",null,"思路"),(0,s._)("p",null,"在.md文件中进行title、tag等内容的标记，在打包项目时运行一个脚本，将所有的.md文件解析处理，生成一个json文件。只有在网页上可以对json文件进行查询操作。"),(0,s._)("h3",null,"生成文章列表json"),(0,s._)("p",null,"通过node.js的fs管理文件，将.md文件解析出来之后，通过正则表达式匹配开头的注释内容。注释不会被vue-markdown-loader编译，所以前端不会展示相关内容"),(0,s._)("pre",null,[(0,s._)("code",{"v-pre":""},"const fs = require('fs');\nconst path = require('path');\n\nconst docsPath = path.resolve(__dirname, 'src/assets/docs');\n\n// 读取所有 Markdown 文件\nconst mdFiles = fs.readdirSync(docsPath).filter(file => file.endsWith('.md'));\n\n// 生成文档目录\nconst docsList = mdFiles.map(file => {\n    const content = fs.readFileSync(path.join(docsPath, file), 'utf-8');\n    const regex = /^\x3c!--\\s*\\n([\\s\\S]*?)\\n--\x3e\\s*\\n/;\n    const titleRegex = /title:\\s*(.*)/;\n    const match = content.match(regex);\n    \n    const titleMatch = match ? match[1].match(titleRegex) : null\n    const title = titleMatch ? titleMatch[1] : 'Untitled';\n    return {\n        title,\n        path: `/docs/${file.replace('.md', '')}` // 假设文档路径为 /docs/文件名\n    };\n});\n\n// 将目录写入 JSON 文件\nfs.writeFileSync(path.resolve(__dirname, 'docsList.json'), JSON.stringify(docsList, null, 2));\n")]),(0,s._)("h3",null,"在serve和build之前时运行脚本"),(0,s._)("p",null,"脚本运行卸载package.json中"),(0,s._)("pre",null,[(0,s._)("code",{"v-pre":""},'  "scripts": {\n    "serve": "(node generateDocsList.js) && (vue-cli-service serve)",\n    "build": "(node generateDocsList.js) && (vue-cli-service build)",\n    "lint": "vue-cli-service lint",\n    "generate-docslist-script":""\n  },\n')])])],-1),c=[l];function i(n,e){return(0,s.wg)(),(0,s.iD)("section",null,c)}var r=t(48998);const o={},a=(0,r.Z)(o,[["render",i]]);var d=a}}]);
//# sourceMappingURL=8514-legacy.0747328d.js.map